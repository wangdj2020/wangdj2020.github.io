<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Redis跳跃表 - Learn &amp; Record</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Learn &amp; Record"><meta name="msapplication-TileImage" content="/gallery/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Learn &amp; Record"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="原文: https:&amp;#x2F;&amp;#x2F;haicoder.net&amp;#x2F;note&amp;#x2F;redis-interview&amp;#x2F;redis-interview-redis-skiplist.html 什么是跳跃表Redis 中的跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。"><meta property="og:type" content="blog"><meta property="og:title" content="Redis跳跃表"><meta property="og:url" content="https://wangdj2020.github.io/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E8%B7%B3%E8%B7%83%E8%A1%A8/"><meta property="og:site_name" content="Learn &amp; Record"><meta property="og:description" content="原文: https:&amp;#x2F;&amp;#x2F;haicoder.net&amp;#x2F;note&amp;#x2F;redis-interview&amp;#x2F;redis-interview-redis-skiplist.html 什么是跳跃表Redis 中的跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135314.png"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135319.png"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135323.png"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135326.png"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135330.png"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135333.png"><meta property="article:published_time" content="2021-04-12T14:13:40.000Z"><meta property="article:author" content="王东杰"><meta property="article:tag" content="redis"><meta property="article:tag" content="2021"><meta property="article:tag" content="redis 进阶"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135314.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wangdj2020.github.io/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E8%B7%B3%E8%B7%83%E8%A1%A8/"},"headline":"Redis跳跃表","image":["https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135314.png","https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135319.png","https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135323.png","https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135326.png","https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135330.png","https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135333.png"],"datePublished":"2021-04-12T14:13:40.000Z","author":{"@type":"Person","name":"王东杰"},"publisher":{"@type":"Organization","name":"Learn & Record","logo":{"@type":"ImageObject","url":{"text":"Learn & Record"}}},"description":"原文: https:&#x2F;&#x2F;haicoder.net&#x2F;note&#x2F;redis-interview&#x2F;redis-interview-redis-skiplist.html 什么是跳跃表Redis 中的跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。"}</script><link rel="canonical" href="https://wangdj2020.github.io/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E8%B7%B3%E8%B7%83%E8%A1%A8/"><link rel="icon" href="/gallery/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Learn &amp; Record</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T14:13:40.000Z" title="2021-4-12 22:13:40">2021-04-12</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></span><span class="level-item">30 分钟读完 (大约4527个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis跳跃表</h1><div class="content"><p>原文: https://haicoder.net/note/redis-interview/redis-interview-redis-skiplist.html</p>
<h2 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表"></a>什么是跳跃表</h2><p><strong><a target="_blank" rel="noopener" href="https://haicoder.net/redis/redis-tutorial.html">Redis</a></strong> 中的跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<span id="more"></span>

<h2 id="为什么使用跳跃表"><a href="#为什么使用跳跃表" class="headerlink" title="为什么使用跳跃表"></a>为什么使用跳跃表</h2><p>首先，因为 <strong><a target="_blank" rel="noopener" href="https://haicoder.net/redis/redis-sortedset.html">zset</a></strong> 要支持随机的插入和删除，所以它不宜使用数组来实现，关于排序问题，我们也很容易就想到红黑树或者平衡树这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p>
<ul>
<li><strong>性能考虑</strong>： 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部；</li>
<li><strong>实现考虑</strong>： 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li>
</ul>
<p>基于以上的一些考虑，Redis 基于 William Pugh 的论文做出一些改进后采用了跳跃表这样的结构。</p>
<h2 id="跳跃表与红黑树"><a href="#跳跃表与红黑树" class="headerlink" title="跳跃表与红黑树"></a>跳跃表与红黑树</h2><p>skip List 是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为 O(logN)（大多数情况下），因为其性能匹敌红黑树且实现较为简单，因此在很多著名项目都用跳表来代替红黑树，例如 LevelDB、Reddis 的底层存储结构就是用的 SkipList。</p>
<p>目前常用的 key-value 数据结构有三种：Hash 表、红黑树、SkipList，它们各自有着不同的优缺点：</p>
<ul>
<li><strong>Hash 表</strong>：插入、查找最快，为 O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。</li>
<li><strong>红黑树</strong>：插入、查找为 O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。</li>
<li><strong>SkipList</strong>：插入、查找为 O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</li>
</ul>
<h2 id="SkipList特点"><a href="#SkipList特点" class="headerlink" title="SkipList特点"></a>SkipList特点</h2><p>一个跳表，应该具有以下特征：</p>
<ol>
<li>一个跳表应该有几个层（level）组成，通常是 10-20 层，leveldb 中默认为 12 层。</li>
<li>跳表的第 0 层包含所有的元素，且节点值是有序的。</li>
<li>每一层都是一个有序的链表，层数越高应越稀疏，这样在高层次中能 ‘跳过’ 许多的不符合条件的数据。</li>
<li>如果元素 x 出现在第 i 层，则所有比 i 小的层都包含 x。</li>
<li>每个节点包含 key 及其对应的 value 和一个指向该节点第 n 层的下个节点的指针数组 x-&gt;next[level] 表示第 level 层的 x 的下一个节点。</li>
</ol>
<h2 id="跳跃表实现详解"><a href="#跳跃表实现详解" class="headerlink" title="跳跃表实现详解"></a>跳跃表实现详解</h2><p>我们先来看一个普通的链表结构：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135314.png" alt="81_redis底层数据结构实现.png"></p>
<p>我们需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，通常我们会使用二分查找法，但二分查找是有序数组的，链表没办法进行位置定位，我们除了遍历整个找到第一个比给定数据大的节点为止 （时间复杂度 O(n)) 似乎没有更好的办法。</p>
<p>但假如我们每相邻两个节点之间就增加一个指针，让指针指向下一个节点，如下图：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135319.png" alt="82_redis底层数据结构实现.png"></p>
<p>这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半。</p>
<p>现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，比如，我们想要查找 7，查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135323.png" alt="83_redis底层数据结构实现.png"></p>
<p>这是一个略微极端的例子，但我们仍然可以看到，通过新增加的指针查找，我们不再需要与链表上的每一个节点逐一进行比较，这样改进之后需要比较的节点数大概只有原来的一半。</p>
<p>利用同样的方式，我们可以在新产生的链表上，继续为每两个相邻的节点增加一个指针，从而产生第三层链表：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135326.png" alt="84_redis底层数据结构实现.png"></p>
<p>在这个新的三层链表结构中，我们试着查找 13，那么沿着最上层链表首先比较的是 11，发现 11 比 13 小，于是我们就知道只需要到 11 后面继续查找，从而一下子跳过了 11 前面的所有节点。</p>
<p>可以想象，当链表足够长，这样的多层链表结构可以帮助我们跳过很多下层节点，从而加快查找的效率。</p>
<h3 id="更进一步的跳跃表"><a href="#更进一步的跳跃表" class="headerlink" title="更进一步的跳跃表"></a>更进一步的跳跃表</h3><p>跳跃表 skiplist 就是受到这种多层链表结构的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 *O(logn)*。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的 2:1 的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点 （也包括新插入的节点） 重新进行调整，这会让时间复杂度重新蜕化成 *O(n)*。删除数据也有同样的问题。</p>
<p>skiplist 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个 skiplist 的过程：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135330.png" alt="85_redis跳跃表.png"></p>
<p>从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整，这就降低了插入操作的复杂度。</p>
<p>现在我们假设从我们刚才创建的这个结构中查找 23 这个不存在的数，那么查找路径会如下图：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135333.png" alt="86_redis跳跃表.png"></p>
<h2 id="Redis跳跃表的实现"><a href="#Redis跳跃表的实现" class="headerlink" title="Redis跳跃表的实现"></a>Redis跳跃表的实现</h2><h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><p>Redis 中的跳跃表由 server.h/zskiplistNode 和 server.h/zskiplist 两个结构定义，前者为跳跃表节点，后者则保存了跳跃节点的相关信息，同之前的 集合 list 结构类似，其实只有 zskiplistNode 就可以实现了，但是引入后者是为了更加方便的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ZSETs use a specialized version of Skiplists *&#x2F;</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    &#x2F;&#x2F; value</span><br><span class="line">    sds ele;</span><br><span class="line">    &#x2F;&#x2F; 分值</span><br><span class="line">    double score;</span><br><span class="line">    &#x2F;&#x2F; 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    &#x2F;&#x2F; 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        &#x2F;&#x2F; 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        &#x2F;&#x2F; 跨度</span><br><span class="line">        unsigned long span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    &#x2F;&#x2F; 跳跃表头指针</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    &#x2F;&#x2F; 表中节点的数量</span><br><span class="line">    unsigned long length;</span><br><span class="line">    &#x2F;&#x2F; 表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>正如文章开头画出来的那张标准的跳跃表那样。</p>
<h3 id="随机层数"><a href="#随机层数" class="headerlink" title="随机层数"></a>随机层数</h3><p>对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数，源码在 t_zset.c/zslRandomLevel(void) 中被定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int zslRandomLevel(void) &#123;</span><br><span class="line">    int level &#x3D; 1;</span><br><span class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))</span><br><span class="line">        level +&#x3D; 1;</span><br><span class="line">    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直观上期望的目标是 50% 的概率被分配到 Level 1，25% 的概率被分配到 Level 2，12.5% 的概率被分配到 Level 3，以此类推…有 2-63 的概率被分配到最顶层，因为这里每一层的晋升率都是 50%。</p>
<p>Redis 跳跃表默认允许最大的层数是 32，被源码中 ZSKIPLIST_MAXLEVEL 定义，当 Level[0] 有 264 个元素时，才能达到 32 层，所以定义 32 完全够用了。</p>
<h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><p>这个过程比较简单，在源码中的 t_zset.c/zslCreate 中被定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">zskiplist *zslCreate(void) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    &#x2F;&#x2F; 申请内存空间</span><br><span class="line">    zsl &#x3D; zmalloc(sizeof(*zsl));</span><br><span class="line">    &#x2F;&#x2F; 初始化层数为 1</span><br><span class="line">    zsl-&gt;level &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 初始化长度为 0</span><br><span class="line">    zsl-&gt;length &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 创建一个层数为 32，分数为 0，没有 value 值的跳跃表头节点</span><br><span class="line">    zsl-&gt;header &#x3D; zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</span><br><span class="line">    &#x2F;&#x2F; 跳跃表头节点初始化</span><br><span class="line">    for (j &#x3D; 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将跳跃表头节点的所有前进指针 forward 设置为 NULL</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward &#x3D; NULL;</span><br><span class="line">        &#x2F;&#x2F; 将跳跃表头节点的所有跨度 span 设置为 0</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 跳跃表头节点的后退指针 backward 置为 NULL</span><br><span class="line">    zsl-&gt;header-&gt;backward &#x3D; NULL;</span><br><span class="line">    &#x2F;&#x2F; 表头指向跳跃表尾节点的指针置为 NULL</span><br><span class="line">    zsl-&gt;tail &#x3D; NULL;</span><br><span class="line">    return zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入节点实现"><a href="#插入节点实现" class="headerlink" title="插入节点实现"></a>插入节点实现</h3><p>这几乎是最重要的一段代码了，但总体思路也比较清晰简单，如果理解了上面所说的跳跃表的原理，那么很容易理清楚插入节点时发生的几个动作 （几乎跟链表类似）：</p>
<ol>
<li>找到当前我需要插入的位置 （其中包括相同 score 时的处理）；</li>
<li>创建新节点，调整前后的指针指向，完成插入；</li>
</ol>
<p>为了方便阅读，我把源码 t_zset.c/zslInsert 定义的插入函数拆成了几个部分</p>
<p><strong>第一部分：声明需要存储的变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 存储搜索路径</span><br><span class="line">zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">&#x2F;&#x2F; 存储经过的节点跨度</span><br><span class="line">unsigned int rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">int i, level;</span><br></pre></td></tr></table></figure>

<p><strong>第二部分：搜索当前节点插入位置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">serverAssert(!isnan(score));</span><br><span class="line">x &#x3D; zsl-&gt;header;</span><br><span class="line">&#x2F;&#x2F; 逐步降级寻找目标节点，得到 &quot;搜索路径&quot;</span><br><span class="line">for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    &#x2F;* store rank that is crossed to reach the insert position *&#x2F;</span><br><span class="line">    rank[i] &#x3D; i &#x3D;&#x3D; (zsl-&gt;level-1) ? 0 : rank[i+1];</span><br><span class="line">    &#x2F;&#x2F; 如果 score 相等，还需要比较 value 值</span><br><span class="line">    while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &#x3D;&#x3D; score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</span><br><span class="line">    &#123;</span><br><span class="line">        rank[i] +&#x3D; x-&gt;level[i].span;</span><br><span class="line">        x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 记录 &quot;搜索路径&quot;</span><br><span class="line">    update[i] &#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种极端的情况，就是跳跃表中的所有 score 值都是一样，zset 的查找性能会不会退化为 O(n) 呢？从上面的源码中我们可以发现 zset 的排序元素不只是看 score 值，也会比较 value 值 （字符串比较）。</p>
<p><strong>第三部分：生成插入节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* we assume the element is not already inside, since we allow duplicated</span><br><span class="line"> * scores, reinserting the same element should never happen since the</span><br><span class="line"> * caller of zslInsert() should test in the hash table if the element is</span><br><span class="line"> * already inside or not. *&#x2F;</span><br><span class="line">level &#x3D; zslRandomLevel();</span><br><span class="line">&#x2F;&#x2F; 如果随机生成的 level 超过了当前最大 level 需要更新跳跃表的信息</span><br><span class="line">if (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        rank[i] &#x3D; 0;</span><br><span class="line">        update[i] &#x3D; zsl-&gt;header;</span><br><span class="line">        update[i]-&gt;level[i].span &#x3D; zsl-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;level &#x3D; level;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建新节点</span><br><span class="line">x &#x3D; zslCreateNode(level,score,ele);</span><br></pre></td></tr></table></figure>

<p><strong>第四部分：重排前向指针</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (i &#x3D; 0; i &lt; level; i++) &#123;</span><br><span class="line">    x-&gt;level[i].forward &#x3D; update[i]-&gt;level[i].forward;</span><br><span class="line">    update[i]-&gt;level[i].forward &#x3D; x;</span><br><span class="line">    &#x2F;* update span covered by update[i] as x is inserted here *&#x2F;</span><br><span class="line">    x-&gt;level[i].span &#x3D; update[i]-&gt;level[i].span - (rank[0] - rank[i]);</span><br><span class="line">    update[i]-&gt;level[i].span &#x3D; (rank[0] - rank[i]) + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* increment span for untouched levels *&#x2F;</span><br><span class="line">for (i &#x3D; level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    update[i]-&gt;level[i].span++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五部分：重排后向指针并返回</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;backward &#x3D; (update[0] &#x3D;&#x3D; zsl-&gt;header) ? NULL : update[0];</span><br><span class="line">if (x-&gt;level[0].forward)</span><br><span class="line">    x-&gt;level[0].forward-&gt;backward &#x3D; x;</span><br><span class="line">else</span><br><span class="line">    zsl-&gt;tail &#x3D; x;</span><br><span class="line">zsl-&gt;length++;</span><br><span class="line">return x;</span><br></pre></td></tr></table></figure>

<h3 id="节点删除实现"><a href="#节点删除实现" class="headerlink" title="节点删除实现"></a>节点删除实现</h3><p>删除过程由源码中的 t_zset.c/zslDeleteNode 定义，和插入过程类似，都需要先把这个 “搜索路径” 找出来，然后对于每个层的相关节点重排一下前向后向指针，同时还要注意更新一下最高层数 maxLevel，直接放源码 (如果理解了插入这里还是很容易理解的)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank *&#x2F;</span><br><span class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        if (update[i]-&gt;level[i].forward &#x3D;&#x3D; x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span +&#x3D; x-&gt;level[i].span - 1;</span><br><span class="line">            update[i]-&gt;level[i].forward &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x-&gt;level[0].forward) &#123;</span><br><span class="line">        x-&gt;level[0].forward-&gt;backward &#x3D; x-&gt;backward;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        zsl-&gt;tail &#x3D; x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward &#x3D;&#x3D; NULL)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* Delete an element with matching score&#x2F;element from the skiplist.</span><br><span class="line"> * The function returns 1 if the node was found and deleted, otherwise</span><br><span class="line"> * 0 is returned.</span><br><span class="line"> *</span><br><span class="line"> * If &#39;node&#39; is NULL the deleted node is freed by zslFreeNode(), otherwise</span><br><span class="line"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span><br><span class="line"> * so that it is possible for the caller to reuse the node (including the</span><br><span class="line"> * referenced SDS string at node-&gt;ele). *&#x2F;</span><br><span class="line">int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    int i;</span><br><span class="line">    x &#x3D; zsl-&gt;header;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score &#x3D;&#x3D; score &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</span><br><span class="line">        &#123;</span><br><span class="line">            x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* We may have multiple elements with the same score, what we need</span><br><span class="line">     * is to find the element with both the right score and object. *&#x2F;</span><br><span class="line">    x &#x3D; x-&gt;level[0].forward;</span><br><span class="line">    if (x &amp;&amp; score &#x3D;&#x3D; x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        if (!node)</span><br><span class="line">            zslFreeNode(x);</span><br><span class="line">        else</span><br><span class="line">            *node &#x3D; x;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; &#x2F;* not found *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节点更新实现"><a href="#节点更新实现" class="headerlink" title="节点更新实现"></a>节点更新实现</h3><p>当我们调用 ZADD 方法时，如果对应的 value 不存在，那就是插入过程，如果这个 value 已经存在，只是调整一下 score 的值，那就需要走一个更新流程。</p>
<p>假设这个新的 score 值并不会带来排序上的变化，那么就不需要调整位置，直接修改元素的 score 值就可以了，但是如果排序位置改变了，那就需要调整位置，该如何调整呢？</p>
<p>从源码 t_zset.c/zsetAdd 函数 1350 行左右可以看到，Redis 采用了一个非常简单的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Remove and re-insert when score changed. *&#x2F;</span><br><span class="line">if (score !&#x3D; curscore) &#123;</span><br><span class="line">    zobj-&gt;ptr &#x3D; zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">    zobj-&gt;ptr &#x3D; zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">    *flags |&#x3D; ZADD_UPDATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这个元素删除再插入这个，需要经过两次路径搜索，从这一点上来看，Redis 的 ZADD 代码似乎还有进一步优化的空间。</p>
<h3 id="元素排名的实现"><a href="#元素排名的实现" class="headerlink" title="元素排名的实现"></a>元素排名的实现</h3><p>跳跃表本身是有序的，Redis 在 skiplist 的 forward 指针上进行了优化，给每一个 forward 指针都增加了 span 属性，用来 表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点。在上面的源码中我们也可以看到 Redis 在插入、删除操作时都会小心翼翼地更新 span 值的大小。</p>
<p>所以，沿着 “搜索路径”，把所有经过节点的跨度 span 值进行累加就可以算出当前元素的最终 rank 值了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Find the rank for an element by both score and key.</span><br><span class="line"> * Returns 0 when the element cannot be found, rank otherwise.</span><br><span class="line"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span><br><span class="line"> * first element. *&#x2F;</span><br><span class="line">unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    unsigned long rank &#x3D; 0;</span><br><span class="line">    int i;</span><br><span class="line">    x &#x3D; zsl-&gt;header;</span><br><span class="line">    for (i &#x3D; zsl-&gt;level-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &#x3D;&#x3D; score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;&#x3D; 0))) &#123;</span><br><span class="line">            &#x2F;&#x2F; span 累加</span><br><span class="line">            rank +&#x3D; x-&gt;level[i].span;</span><br><span class="line">            x &#x3D; x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* x might be equal to zsl-&gt;header, so test if obj is non-NULL *&#x2F;</span><br><span class="line">        if (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Redis跳跃表常用操作的时间复杂度"><a href="#Redis跳跃表常用操作的时间复杂度" class="headerlink" title="Redis跳跃表常用操作的时间复杂度"></a>Redis跳跃表常用操作的时间复杂度</h2><p>| 操作                                                         | 时间复杂度                               |
| ———————————————————— | —————————————- |
| 创建一个跳跃表                                               | O(1)                                     |
| 释放给定跳跃表以及其中包含的节点                             | O(N)                                     |
| 添加给定成员和分值的新节点                                   | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |
| 删除除跳跃表中包含给定成员和分值的节点                       | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |
| 返回给定成员和分值的节点再表中的排位                         | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |
| 返回在给定排位上的节点                                       | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |
| 给定一个分值范围,返回跳跃表中第一个符合这个范围的节点        | O(1)                                     |
| 给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点      | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |
| 给定一个分值范围,除跳跃表中所有在这个范围之内的节点          | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |
| 给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点        | O(N),N为被除节点数量                     |
| 给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0 | O(N),N为被除节点数量                     |</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>跳跃表基于单链表加索引的方式实现。</li>
<li>跳跃表以空间换时间的方式提升了查找速度。</li>
<li>Redis 有序集合在节点元素较大或者元素数量较多时使用跳跃表实现。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistnode 两个结构组成，其中 zskiplist 用于保存跳跃表信息(比如表头节点、表尾节点、长度)，而 zskiplistnode 则用于表示跳跃表节点。</li>
<li>Redis 每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li>
</ol>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/redis/">redis</a><a class="link-muted mr-2" rel="tag" href="/tags/2021/">2021</a><a class="link-muted mr-2" rel="tag" href="/tags/redis-%E8%BF%9B%E9%98%B6/">redis 进阶</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Redis为什么这么快</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96rdb%E4%B8%8Eaof/"><span class="level-item">Redis数据持久化RDB与AOF</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-011456.jpg" alt="王东杰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">王东杰</p><p class="is-size-6 is-block">Time is limited.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wangdj2020/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wangdj2020/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是跳跃表"><span class="level-left"><span class="level-item">1</span><span class="level-item">什么是跳跃表</span></span></a></li><li><a class="level is-mobile" href="#为什么使用跳跃表"><span class="level-left"><span class="level-item">2</span><span class="level-item">为什么使用跳跃表</span></span></a></li><li><a class="level is-mobile" href="#跳跃表与红黑树"><span class="level-left"><span class="level-item">3</span><span class="level-item">跳跃表与红黑树</span></span></a></li><li><a class="level is-mobile" href="#SkipList特点"><span class="level-left"><span class="level-item">4</span><span class="level-item">SkipList特点</span></span></a></li><li><a class="level is-mobile" href="#跳跃表实现详解"><span class="level-left"><span class="level-item">5</span><span class="level-item">跳跃表实现详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#更进一步的跳跃表"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">更进一步的跳跃表</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Redis跳跃表的实现"><span class="level-left"><span class="level-item">6</span><span class="level-item">Redis跳跃表的实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#结构定义"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">结构定义</span></span></a></li><li><a class="level is-mobile" href="#随机层数"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">随机层数</span></span></a></li><li><a class="level is-mobile" href="#创建跳跃表"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">创建跳跃表</span></span></a></li><li><a class="level is-mobile" href="#插入节点实现"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">插入节点实现</span></span></a></li><li><a class="level is-mobile" href="#节点删除实现"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">节点删除实现</span></span></a></li><li><a class="level is-mobile" href="#节点更新实现"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">节点更新实现</span></span></a></li><li><a class="level is-mobile" href="#元素排名的实现"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">元素排名的实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Redis跳跃表常用操作的时间复杂度"><span class="level-left"><span class="level-item">7</span><span class="level-item">Redis跳跃表常用操作的时间复杂度</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">感悟</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"><span class="level-start"><span class="level-item">知识体系</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-12T03:25:16.000Z">2021-05-12</time></p><p class="title"><a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%99%86%E5%A5%87-%E6%95%B0%E5%AD%97%E5%8C%96%E6%9C%AA%E6%9D%A5-%E6%91%98%E5%BD%95/">陆奇-数字化未来-摘录</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-18T09:42:26.000Z">2021-04-18</time></p><p class="title"><a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%98%E9%B9%8F-%E7%BB%8F%E6%B5%8E%E4%B8%96%E7%95%8C%E8%A7%82-%E5%85%A8%E6%96%87/">付鹏-经济世界观-全文</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-16T06:58:56.000Z">2021-04-16</time></p><p class="title"><a href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/mac-%E7%BB%88%E7%AB%AF%E4%BC%98%E5%8C%96/">MAC 终端优化</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-16T06:48:32.000Z">2021-04-16</time></p><p class="title"><a href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/">各种开源协议介绍</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-16T06:47:41.000Z">2021-04-16</time></p><p class="title"><a href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/linux%E4%B8%AD%E7%9A%84sh%E3%80%81dash%E3%80%81bash%E7%9A%84%E5%8C%BA%E5%88%AB/">linux中的sh、dash、bash的区别</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/2020/"><span class="tag">2020</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/2021/"><span class="tag">2021</span><span class="tag">44</span></a></div><div class="control"><a class="tags has-addons" href="/tags/economy/"><span class="tag">economy</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/future/"><span class="tag">future</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/license/"><span class="tag">license</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/life/"><span class="tag">life</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/reading/"><span class="tag">reading</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis-%E8%BF%9B%E9%98%B6/"><span class="tag">redis 进阶</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/terminal/"><span class="tag">terminal</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/time-management/"><span class="tag">time management</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Learn &amp; Record</a><p class="is-size-7"><span>&copy; 2021 王东杰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>