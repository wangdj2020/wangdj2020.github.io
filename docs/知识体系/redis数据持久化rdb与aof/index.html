<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Redis数据持久化RDB与AOF - Learn &amp; Record</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Learn &amp; Record"><meta name="msapplication-TileImage" content="/gallery/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Learn &amp; Record"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="原文：https:&amp;#x2F;&amp;#x2F;haicoder.net&amp;#x2F;note&amp;#x2F;redis-interview&amp;#x2F;redis-interview-redis-rdb-aof.html Redis数据持久化Redis 作为一个内存数据库，数据是以内存为载体存储的，那么一旦 Redis 服务器进程退出，服务器中的数据也会消失。为了解决这个问题，Redis 提供了持久化机制，也就是把内存中的数据保存到磁盘当中，避免数据意外丢失"><meta property="og:type" content="blog"><meta property="og:title" content="Redis数据持久化RDB与AOF"><meta property="og:url" content="https://wangdj2020.github.io/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96rdb%E4%B8%8Eaof/"><meta property="og:site_name" content="Learn &amp; Record"><meta property="og:description" content="原文：https:&amp;#x2F;&amp;#x2F;haicoder.net&amp;#x2F;note&amp;#x2F;redis-interview&amp;#x2F;redis-interview-redis-rdb-aof.html Redis数据持久化Redis 作为一个内存数据库，数据是以内存为载体存储的，那么一旦 Redis 服务器进程退出，服务器中的数据也会消失。为了解决这个问题，Redis 提供了持久化机制，也就是把内存中的数据保存到磁盘当中，避免数据意外丢失"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135252.png"><meta property="og:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135259.png"><meta property="article:published_time" content="2021-04-12T14:12:39.000Z"><meta property="article:author" content="王东杰"><meta property="article:tag" content="redis"><meta property="article:tag" content="2021"><meta property="article:tag" content="redis 进阶"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135252.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wangdj2020.github.io/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96rdb%E4%B8%8Eaof/"},"headline":"Redis数据持久化RDB与AOF","image":["https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135252.png","https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135259.png"],"datePublished":"2021-04-12T14:12:39.000Z","author":{"@type":"Person","name":"王东杰"},"publisher":{"@type":"Organization","name":"Learn & Record","logo":{"@type":"ImageObject","url":{"text":"Learn & Record"}}},"description":"原文：https:&#x2F;&#x2F;haicoder.net&#x2F;note&#x2F;redis-interview&#x2F;redis-interview-redis-rdb-aof.html Redis数据持久化Redis 作为一个内存数据库，数据是以内存为载体存储的，那么一旦 Redis 服务器进程退出，服务器中的数据也会消失。为了解决这个问题，Redis 提供了持久化机制，也就是把内存中的数据保存到磁盘当中，避免数据意外丢失"}</script><link rel="canonical" href="https://wangdj2020.github.io/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96rdb%E4%B8%8Eaof/"><link rel="icon" href="/gallery/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Learn &amp; Record</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T14:12:39.000Z" title="2021-4-12 22:12:39">2021-04-12</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></span><span class="level-item">32 分钟读完 (大约4782个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis数据持久化RDB与AOF</h1><div class="content"><p>原文：https://haicoder.net/note/redis-interview/redis-interview-redis-rdb-aof.html</p>
<h2 id="Redis数据持久化"><a href="#Redis数据持久化" class="headerlink" title="Redis数据持久化"></a>Redis数据持久化</h2><p><strong><a target="_blank" rel="noopener" href="https://haicoder.net/redis/redis-tutorial.html">Redis</a></strong> 作为一个内存数据库，数据是以内存为载体存储的，那么一旦 Redis 服务器进程退出，服务器中的数据也会消失。为了解决这个问题，Redis 提供了持久化机制，也就是把内存中的数据保存到磁盘当中，避免数据意外丢失。</p>
<p>Redis 提供了两种持久化方案：RDB 持久化和 AOF 持久化，一个是快照的方式，一个是类似日志追加的方式。</p>
<span id="more"></span>

<h2 id="RDB快照持久化"><a href="#RDB快照持久化" class="headerlink" title="RDB快照持久化"></a>RDB快照持久化</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RDB 持久化是通过快照的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。在创建快照之后，用户可以备份该快照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。RDB 是 Redis 默认的持久化方式。</p>
<h3 id="快照持久化"><a href="#快照持久化" class="headerlink" title="快照持久化"></a>快照持久化</h3><p>RDB 持久化会生成 RDB 文件，该文件是一个压缩过的二进制文件，可以通过该文件还原快照时的数据库状态，即生成该 RDB 文件时的服务器数据。RDB 文件默认为当前工作目录下的 dump.rdb，可以根据配置文件中的 dbfilename 和 dir 设置 RDB 的文件名和文件位置，具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置dump的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 工作目录</span><br><span class="line"># 例如上面的dbfilename只指定了文件名，但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。</span><br><span class="line">dir .&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># RDB自动持久化规则</span><br><span class="line"># 当 900 秒内有至少有 1 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 900 1</span><br><span class="line"># 当 300 秒内有至少有 10 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 300 10</span><br><span class="line"># 当 60 秒内有至少有 10000 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># RDB持久化文件名</span><br><span class="line">dbfilename dump-&lt;port&gt;.rdb</span><br><span class="line"></span><br><span class="line"># 数据持久化文件存储目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"></span><br><span class="line"># bgsave发生错误时是否停止写入，通常为yes</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># rdb文件是否使用压缩格式</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否对rdb文件进行校验和检验，通常为yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<h3 id="触发快照的时机"><a href="#触发快照的时机" class="headerlink" title="触发快照的时机"></a>触发快照的时机</h3><ul>
<li>执行 save 和 bgsave 命令</li>
<li>配置文件设置 <code>save &lt;seconds&gt; &lt;changes&gt;</code> 规则，自动间隔性执行 bgsave 命令</li>
<li>主从复制时，从库全量复制同步主库数据，主库会执行 bgsave</li>
<li>执行 flushall 命令清空服务器数据</li>
<li>执行 shutdown 命令关闭 Redis 时，会执行 save 命令</li>
</ul>
<h3 id="save和bgsave命令区别"><a href="#save和bgsave命令区别" class="headerlink" title="save和bgsave命令区别"></a>save和bgsave命令区别</h3><p>执行 save 和 bgsave 命令，可以手动触发快照，生成 RDB 文件，两者的区别为使用 save 命令会阻塞 Redis 服务器进程，服务器进程在 RDB 文件创建完成之前是不能处理任何的命令请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>而使用 bgsave 命令不同的是，bgsave 命令会 fork 一个子进程，然后该子进程会负责创建 RDB 文件，而服务器进程会继续处理命令请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>

<p>其中，fork() 是由操作系统提供的函数，作用是创建当前进程的一个副本作为子进程，具体流程如下：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135252.png" alt="07_Redis持久化RDB和AOF.png"></p>
<p>fork 一个子进程，子进程会把数据集先写入临时文件，写入成功之后，再替换之前的 RDB 文件，用二进制压缩存储，这样可以保证 RDB 文件始终存储的是完整的持久化内容。</p>
<h3 id="自动间隔触发"><a href="#自动间隔触发" class="headerlink" title="自动间隔触发"></a>自动间隔触发</h3><p>在配置文件中设置 <code>save &lt;seconds&gt; &lt;changes&gt;</code> 规则，可以自动间隔性执行 bgsave 命令，具体配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p><code>save &lt;seconds&gt; &lt;changes&gt;</code> 表示在 seconds 秒内，至少有 changes 次变化，就会自动触发 bgsave 命令，具体配置解释如下：</p>
<p>| 配置          | 描述                                                         |
| ————- | ———————————————————— |
| save 900 1    | 当时间到900秒时，如果至少有1个key发生变化，就会自动触发bgsave命令创建快照 |
| save 300 10   | 当时间到300秒时，如果至少有10个key发生变化，就会自动触发bgsave命令创建快照 |
| save 60 10000 | 当时间到60秒时，如果至少有10000个key发生变化，就会自动触发bgsave命令创建快照 |</p>
<h3 id="save与bgsave"><a href="#save与bgsave" class="headerlink" title="save与bgsave"></a>save与bgsave</h3><p>| 命令   | save               | bgsave                             |
| —— | —————— | ———————————- |
| IO类型 | 同步               | 异步                               |
| 阻塞？ | 是                 | 是（阻塞发生在fock()，通常非常快） |
| 复杂度 | O(n)               | O(n)                               |
| 优点   | 不会消耗额外的内存 | 不阻塞客户端命令                   |
| 缺点   | 阻塞客户端命令     | 需要fock子进程，消耗内存           |</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>除了 RDB 持久化，Redis 还提供了 AOF（Append Only File）持久化功能，AOF 持久化会把被执行的写命令写到 AOF 文件的末尾，记录数据的变化。默认情况下，Redis 是没有开启 AOF 持久化的，开启后，每执行一条更改 Redis 数据的命令，都会把该命令追加到 AOF 文件中，这是会降低 Redis 的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高 AOF 的性能。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以通过配置 redis.conf 文件开启 AOF 持久化，关于 AOF 的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># appendonly参数开启AOF持久化</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir .&#x2F;</span><br><span class="line"></span><br><span class="line"># 同步策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>

<h3 id="AOF的实现"><a href="#AOF的实现" class="headerlink" title="AOF的实现"></a>AOF的实现</h3><p>AOF 需要记录 Redis 的每个写命令，步骤为：命令追加（append）、文件写入（write）和文件同步（sync）。</p>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>开启 AOF 持久化功能后，服务器每执行一个写命令，都会把该命令以协议格式先追加到 aof_buf 缓存区的末尾，而不是直接写入文件，避免每次有命令都直接写入硬盘，减少硬盘 IO 次数。</p>
<h4 id="文件写入和同步"><a href="#文件写入和同步" class="headerlink" title="文件写入和同步"></a>文件写入和同步</h4><p>对于何时把 aof_buf 缓冲区的内容写入保存在 AOF 文件中，Redis 提供了多种策略：</p>
<p>| 配置                 | 描述                                                         |
| ——————– | ———————————————————— |
| appendfsync always   | 将 aof_buf 缓冲区的所有内容写入并同步到 AOF 文件，每个写命令同步写入磁盘 |
| appendfsync everysec | 将 aof_buf 缓存区的内容写入 AOF 文件，每秒同步一次，该操作由一个线程专门负责 |
| appendfsync no       | 将 aof_buf 缓存区的内容写入 AOF 文件，什么时候同步由操作系统来决定 |</p>
<p>appendfsync 选项的默认配置为 everysec，即每秒执行一次同步，关于 AOF 的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在 <code>《Redis设计与实现》</code> 中是这样说明的：</p>
<p>为了提高文件写入效率，在现代操作系统中，当用户调用 write 函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p>
<p>这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了 fsync、fdatasync 同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p>
<p>从上面的介绍我们知道，我们写入的数据，操作系统并不一定会马上同步到磁盘，所以 Redis 才提供了 appendfsync 的选项配置。当该选项时为 always 时，数据安全性是最高的，但是会对磁盘进行大量的写入，Redis 处理命令的速度会受到磁盘性能的限制；appendfsync everysec 选项则兼顾了数据安全和写入性能，以每秒一次的频率同步 AOF 文件，即便出现系统崩溃，最多只会丢失一秒内产生的数据；如果是 appendfsync no 选项，Redis 不会对 AOF 文件执行同步操作，而是有操作系统决定何时同步，不会对 Redis 的性能带来影响，但假如系统崩溃，可能会丢失不定数量的数据。</p>
<h4 id="always、everysec、no对比"><a href="#always、everysec、no对比" class="headerlink" title="always、everysec、no对比"></a>always、everysec、no对比</h4><p>| 命令     | 优点                             | 缺点                              |
| ——– | ——————————– | ——————————— |
| always   | 不丢失数据                       | IO开销大，一般SATA磁盘只有几百TPS |
| everysec | 每秒进行与fsync，最多丢失1秒数据 | 可能丢失1秒数据                   |
| no       | 不用管                           | 不可控                            |</p>
<h3 id="AOF重写-rewrite"><a href="#AOF重写-rewrite" class="headerlink" title="AOF重写(rewrite)"></a>AOF重写(rewrite)</h3><p>在了解 AOF 重写之前，我们先来看看 AOF 文件中存储的内容是啥，先执行两个写操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set s1 hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set s2 world</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>然后我们打开 appendonly.aof 文件，可以看到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$2</span><br><span class="line">s1</span><br><span class="line">$5</span><br><span class="line">hello</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$2</span><br><span class="line">s2</span><br><span class="line">$5</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>该命令格式为 Redis 的序列化协议（RESP）。<code>*3</code> 代表这个命令有三个参数，<code>$3</code> 表示该参数长度为 3，看了上面的 AOP 文件的内容，我们应该能想象，随着时间的推移，Redis 执行的写命令会越来越多，AOF 文件也会越来越大，过大的 AOF 文件可能会对 Redis 服务器造成影响，如果使用 AOF 文件来进行数据还原所需时间也会越长。</p>
<p>时间长了，AOF 文件中通常会有一些冗余命令，比如：过期数据的命令、无效的命令（重复设置、删除）、多个命令可合并为一个命令（批处理命令）。所以 AOF 文件是有精简压缩的空间的。</p>
<p>AOF 重写的目的就是减小 AOF 文件的体积，不过值得注意的是：AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分享和写入操作，而是通过读取服务器当前的数据库状态来实现的，文件重写可分为手动触发和自动触发，手动触发执行 bgrewriteaof 命令，该命令的执行跟 bgsave 触发快照时类似的，都是先 fork 一个子进程做具体的工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgrewriteaof</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure>

<p>自动触发会根据 auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size 64mb 配置来自动执行 bgrewriteaof 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 表示当AOF文件的体积大于64MB，且AOF文件的体积比上一次重写后的体积大了一倍（100%）时，会执行&#96;bgrewriteaof&#96;命令</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>下面看一下执行 bgrewriteaof 命令，重写的流程：</p>
<p><img src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135259.png" alt="08_Redis持久化RDB和AOF.png"></p>
<p>说明如下：</p>
<ol>
<li>重写会有大量的写入操作，所以服务器进程会 fork 一个子进程来创建一个新的 AOF 文件</li>
<li>在重写期间，服务器进程继续处理命令请求，如果有写入的命令，追加到 aof_buf 的同时，还会追加到 aof_rewrite_buf AOF 重写缓冲区</li>
<li>当子进程完成重写之后，会给父进程一个信号，然后父进程会把 AOF 重写缓冲区的内容写进新的 AOF 临时文件中，再对新的 AOF 文件改名完成替换，这样可以保证新的 AOF 文件与当前数据库数据的一致性</li>
</ol>
<h3 id="AOF重写配置"><a href="#AOF重写配置" class="headerlink" title="AOF重写配置"></a>AOF重写配置</h3><p>| 配置名                      | 含义                          |
| ————————— | —————————– |
| auto-aof-rewrite-min-size   | 触发AOF文件执行重写的最小尺寸 |
| auto-aof-rewrite-percentage | 触发AOF文件执行重写的增长率   |</p>
<p>| 统计名           | 含义                                  |
| —————- | ————————————- |
| aof_current_size | AOF文件当前尺寸（字节）               |
| aof_base_size    | AOF文件上次启动和重写时的尺寸（字节） |</p>
<p>AOF重写自动触发机制，需要同时满足下面两个条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size &gt; auto-aof-rewrite-min-size</span><br><span class="line">(aof_current_size - aof_base_size) * 100 &#x2F; aof_base_size &gt; auto-aof-rewrite-percentage</span><br></pre></td></tr></table></figure>

<p>假设 Redis 的配置项为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure>

<p>当 AOF 文件的体积大于 64Mb，并且 AOF 文件的体积比上一次重写之久的体积大了至少一倍（100%）时，Redis 将执行 bgrewriteaof 命令进行重写。</p>
<h3 id="AOF重写原理"><a href="#AOF重写原理" class="headerlink" title="AOF重写原理"></a>AOF重写原理</h3><p>当 AOF 文件的大小超过所设定的阈值时，redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。假如我们调用了 100 次 <strong>INCR</strong> 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令，这就是重写机制的原理。</p>
<p>在进行 AOF 重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性。</p>
<p>AOF 方式的另一个好处，我们通过一个 “场景再现” 来说明。某同学在操作 redis 时，不小心执行了 flushall，导致 redis 内存中的数据全部被清空了，只要 redis 配置了 AOF 持久化方式，且 AOF 文件还没有被重写（rewrite），我们就可以用最快的速度暂停 redis 并编辑 AOF 文件，将最后一行的 FLUSHALL 命令删除，然后重启 redis，就可以恢复 redis 的所有数据到 FLUSHALL 之前的状态了。但是如果 AOF 文件已经被重写了，那就无法通过这种方法来恢复数据了。</p>
<h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><p>Redis4.0 开始支持 RDB 和 AOF 的混合持久化（可以通过配置项 aof-use-rdb-preamble 开启）</p>
<ul>
<li>如果是 redis 进程挂掉，那么重启 redis 进程即可，直接基于 AOF 日志文件恢复数据</li>
<li>如果是 redis 进程所在机器挂掉，那么重启机器后，尝试重启 redis 进程，尝试直接基于 AOF 日志文件进行数据恢复，如果 AOF 文件破损，那么用 redis-check-aof fix 命令修复</li>
<li>如果没有 AOF 文件，会去加载 RDB 文件</li>
<li>如果 redis 当前最新的 AOF 和 RDB 文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的 RDB 数据副本进行数据恢复</li>
</ul>
<h2 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>RDB 快照是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份，灾难恢复</li>
<li>可以最大化 Redis 的性能，在保存 RDB 文件，服务器进程只需 fork 一个子进程来完成 RDB 文件的创建，父进程不需要做 IO 操作</li>
<li>与 AOF 相比，恢复大数据集的时候会更快</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>RDB 的数据安全性是不如 AOF 的，保存整个数据集的过程是比繁重的，根据配置可能要几分钟才快照一次，如果服务器宕机，那么就可能丢失几分钟的数据</li>
<li>Redis 数据集较大时，fork 的子进程要完成快照会比较耗CPU、耗时</li>
</ul>
<h2 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>数据更完整，安全性更高，秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失1秒的数据）</li>
<li>AOF 文件是一个只进行追加的日志文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对于相同的数据集，AOF 文件的体积要大于 RDB 文件，数据恢复也会比较慢</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 不过在一般情况下， 每秒 fsync 的性能依然非常高</li>
</ul>
<h2 id="RDB和AOF选择"><a href="#RDB和AOF选择" class="headerlink" title="RDB和AOF选择"></a>RDB和AOF选择</h2><ul>
<li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化</li>
<li>如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用 RDB</li>
<li>如果是用做内存数据库，要使用 Redis 的持久化，建议是 RDB 和 AOF 都开启，或者定期执行 bgsave 做快照备份，RDB 方式更适合做数据的备份，AOF 可以保证数据的不丢失</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RDB 是将某一时刻的数据持久化到磁盘中，是一种快照的方式。redis 在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，即使 redis 处于运行状态。</p>
<p>生成 RDB 文件有两种方式，即手动触发与自动触发。</p>
<p>AOF 方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍。同样数据集的情况下，AOF 文件要比RDB文件的体积大。而且，AOF 方式的恢复速度也要慢于 RDB 方式。</p>
<p>如果在追加日志时，恰好遇到磁盘空间满、inode 满或断电等情况导致日志写入不完整，redis 提供了 redis-check-aof 工 具，可以用来进行日志修复。</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/redis/">redis</a><a class="link-muted mr-2" rel="tag" href="/tags/2021/">2021</a><a class="link-muted mr-2" rel="tag" href="/tags/redis-%E8%BF%9B%E9%98%B6/">redis 进阶</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E8%B7%B3%E8%B7%83%E8%A1%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Redis跳跃表</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/redis%E4%BA%8B%E5%8A%A1/"><span class="level-item">Redis事务</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-011456.jpg" alt="王东杰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">王东杰</p><p class="is-size-6 is-block">Time is limited.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wangdj2020/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wangdj2020/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Redis数据持久化"><span class="level-left"><span class="level-item">1</span><span class="level-item">Redis数据持久化</span></span></a></li><li><a class="level is-mobile" href="#RDB快照持久化"><span class="level-left"><span class="level-item">2</span><span class="level-item">RDB快照持久化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">概念</span></span></a></li><li><a class="level is-mobile" href="#快照持久化"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">快照持久化</span></span></a></li><li><a class="level is-mobile" href="#相关配置"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">相关配置</span></span></a></li><li><a class="level is-mobile" href="#触发快照的时机"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">触发快照的时机</span></span></a></li><li><a class="level is-mobile" href="#save和bgsave命令区别"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">save和bgsave命令区别</span></span></a></li><li><a class="level is-mobile" href="#自动间隔触发"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">自动间隔触发</span></span></a></li><li><a class="level is-mobile" href="#save与bgsave"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">save与bgsave</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AOF持久化"><span class="level-left"><span class="level-item">3</span><span class="level-item">AOF持久化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概念-1"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">概念</span></span></a></li><li><a class="level is-mobile" href="#配置"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">配置</span></span></a></li><li><a class="level is-mobile" href="#AOF的实现"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">AOF的实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#命令追加"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">命令追加</span></span></a></li><li><a class="level is-mobile" href="#文件写入和同步"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">文件写入和同步</span></span></a></li><li><a class="level is-mobile" href="#always、everysec、no对比"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">always、everysec、no对比</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AOF重写-rewrite"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">AOF重写(rewrite)</span></span></a></li><li><a class="level is-mobile" href="#AOF重写配置"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">AOF重写配置</span></span></a></li><li><a class="level is-mobile" href="#AOF重写原理"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">AOF重写原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据恢复"><span class="level-left"><span class="level-item">4</span><span class="level-item">数据恢复</span></span></a></li><li><a class="level is-mobile" href="#RDB优缺点"><span class="level-left"><span class="level-item">5</span><span class="level-item">RDB优缺点</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#优点"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">优点</span></span></a></li><li><a class="level is-mobile" href="#缺点"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">缺点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AOF优缺点"><span class="level-left"><span class="level-item">6</span><span class="level-item">AOF优缺点</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#优点-1"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">优点</span></span></a></li><li><a class="level is-mobile" href="#缺点-1"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">缺点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#RDB和AOF选择"><span class="level-left"><span class="level-item">7</span><span class="level-item">RDB和AOF选择</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">感悟</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"><span class="level-start"><span class="level-item">知识体系</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-12T03:25:16.000Z">2021-05-12</time></p><p class="title"><a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%99%86%E5%A5%87-%E6%95%B0%E5%AD%97%E5%8C%96%E6%9C%AA%E6%9D%A5-%E6%91%98%E5%BD%95/">陆奇-数字化未来-摘录</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-18T09:42:26.000Z">2021-04-18</time></p><p class="title"><a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%98%E9%B9%8F-%E7%BB%8F%E6%B5%8E%E4%B8%96%E7%95%8C%E8%A7%82-%E5%85%A8%E6%96%87/">付鹏-经济世界观-全文</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-16T06:58:56.000Z">2021-04-16</time></p><p class="title"><a href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/mac-%E7%BB%88%E7%AB%AF%E4%BC%98%E5%8C%96/">MAC 终端优化</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-16T06:48:32.000Z">2021-04-16</time></p><p class="title"><a href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/">各种开源协议介绍</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-16T06:47:41.000Z">2021-04-16</time></p><p class="title"><a href="/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/linux%E4%B8%AD%E7%9A%84sh%E3%80%81dash%E3%80%81bash%E7%9A%84%E5%8C%BA%E5%88%AB/">linux中的sh、dash、bash的区别</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">知识体系</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/2020/"><span class="tag">2020</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/2021/"><span class="tag">2021</span><span class="tag">44</span></a></div><div class="control"><a class="tags has-addons" href="/tags/economy/"><span class="tag">economy</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/future/"><span class="tag">future</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/license/"><span class="tag">license</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/life/"><span class="tag">life</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/reading/"><span class="tag">reading</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis-%E8%BF%9B%E9%98%B6/"><span class="tag">redis 进阶</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/terminal/"><span class="tag">terminal</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/time-management/"><span class="tag">time management</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Learn &amp; Record</a><p class="is-size-7"><span>&copy; 2021 王东杰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>